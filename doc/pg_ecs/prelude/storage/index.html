<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A “packed archetype” storage model."><title>pg_ecs::prelude::storage - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="pg_ecs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../pg_ecs/index.html">pg_ecs</a><span class="version">0.1.0</span></h2></div><h2 class="location"><a href="#">Module storage</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li></ul></section><h2><a href="../index.html">In pg_ecs::prelude</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">pg_ecs</a>::<wbr><a href="../index.html">prelude</a>::<wbr><a class="mod" href="#">storage</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../../src/legion/lib.rs.html#190">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A “packed archetype” storage model.</p>
<p>Any combination of types of components can be attached to each entity
in a <a href="../world/struct.World.html">world</a>. Storing the (potentially
unique) set of component values for each entity in a manor which is
efficient to search and access is the responsibility of the ECS libary.</p>
<p>Legion achieves this via the use of “archetypes”. Archetypes are a
collection of entities who all have exactly the same set of component
types attached. By storing these together, we can perform filtering
operations at the archetype level without needing to ever inspect each
individual entity. Archetypes also allow us to store contiguous and
ordered arrays of each component. For example, all <code>Position</code> components
for all entities in an archetype are stored together in one array, and
can be returned from queries as a slice. All component arrays for an
archetype are stored in the same order and are necessarily the same
length, allowing us to index them together to access the components for
a single entity.</p>
<p>Because these components are stored contiguously in memory, iterating
through the components in an archetype is extremely performant as
it offers perfect cache coherence. By storing each component type in
its own array, we only need to access the memory containing components
actually reqested by the query’s view (see the
<a href="../query/index.html">query module</a>).</p>
<p>One of the disadvantages of archetypes is that there are discontinuities
between component arrays of different archetypes. In practise this causes
approximately one additional L2/3 cache miss per unique entity layout that
exists among the result set of a query.</p>
<p>Legion mitigates this by conservatively packing archetype component
slices next to each other. A component slice is considered eligable
for packing if its components have remained stable for some time (i.e no
entities have been added or removed from the archetype recently) and
and estimate of potential saved cache misses passes a “worthwhile”
threshold.</p>
<p>By default, legion will pack component slices in the order in which
the archetypes were created. This matches the order in which queries will
attempt to access each slice. However, most queries do not access all
archetypes that contain a certain component - more likely they will skip
past many archetypes due to other filters (such as only being interested
in archetypes which also contain another specific component).</p>
<p>We can provide hints to a world about how it should pack archetypes by
declaring groups with the world’s <a href="../world/struct.WorldOptions.html">options</a>
which can be provided while constructing the world. Component groups can be
used to accelerate the largest and most common queries by optmizing the data
layout for those queries.</p>
<p>Each component type in a world may belong to precisely one group. A group is
a set of components which are frequently queried for together. Queries which
match a group will not suffer from performance loss due to archetype
fragmentation.</p>
<p>Each group implicitly also defines sub-groups, such that the group
<code>(A, B, C, D)</code> also defines the groups <code>(A, B, C)</code> and <code>(A, B)</code>.</p>
<p>Groups are defined before constructing a world and are passed in the world’s
options.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// our component types
</span><span class="kw">struct </span>A;
<span class="kw">struct </span>B;
<span class="kw">struct </span>C;

<span class="comment">// create a world optimized for cases where (A, B) and/or
// (A, B, C) are significant queries.
</span><span class="kw">let </span>group = &lt;(A, B, C)&gt;::to_group();
<span class="kw">let </span>options = WorldOptions { groups: <span class="macro">vec!</span>[group] };
<span class="kw">let </span>world = World::new(options);</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Archetype.html" title="struct pg_ecs::prelude::storage::Archetype">Archetype</a></div><div class="desc docblock-short">An archetype is a collection of entities which all have identical component types.</div></li><li><div class="item-name"><a class="struct" href="struct.ArchetypeIndex.html" title="struct pg_ecs::prelude::storage::ArchetypeIndex">ArchetypeIndex</a></div><div class="desc docblock-short">The index of an archetype in a world.</div></li><li><div class="item-name"><a class="struct" href="struct.ArchetypeWriter.html" title="struct pg_ecs::prelude::storage::ArchetypeWriter">ArchetypeWriter</a></div><div class="desc docblock-short">Provides access to writers for writing new entities into an archetype in a world.</div></li><li><div class="item-name"><a class="struct" href="struct.ComponentIndex.html" title="struct pg_ecs::prelude::storage::ComponentIndex">ComponentIndex</a></div><div class="desc docblock-short">The index of a component within an archetype.</div></li><li><div class="item-name"><a class="struct" href="struct.ComponentMeta.html" title="struct pg_ecs::prelude::storage::ComponentMeta">ComponentMeta</a></div><div class="desc docblock-short">Contains information about the type of a component.</div></li><li><div class="item-name"><a class="struct" href="struct.ComponentSlice.html" title="struct pg_ecs::prelude::storage::ComponentSlice">ComponentSlice</a></div><div class="desc docblock-short">An accessor for a shared slice reference of components for a single archetype.</div></li><li><div class="item-name"><a class="struct" href="struct.ComponentSliceMut.html" title="struct pg_ecs::prelude::storage::ComponentSliceMut">ComponentSliceMut</a></div><div class="desc docblock-short">An accessor for a mutable slice reference of components for a single archetype.</div></li><li><div class="item-name"><a class="struct" href="struct.ComponentTypeId.html" title="struct pg_ecs::prelude::storage::ComponentTypeId">ComponentTypeId</a></div><div class="desc docblock-short">A unique ID for a component type.</div></li><li><div class="item-name"><a class="struct" href="struct.ComponentTypeIdHasher.html" title="struct pg_ecs::prelude::storage::ComponentTypeIdHasher">ComponentTypeIdHasher</a></div><div class="desc docblock-short">A hasher optimized for hashing component type IDs.</div></li><li><div class="item-name"><a class="struct" href="struct.ComponentWriter.html" title="struct pg_ecs::prelude::storage::ComponentWriter">ComponentWriter</a></div><div class="desc docblock-short">Provides the ability to append new components to the entities in an archetype.</div></li><li><div class="item-name"><a class="struct" href="struct.Components.html" title="struct pg_ecs::prelude::storage::Components">Components</a></div><div class="desc docblock-short">Contains the storages for all component types in a world.</div></li><li><div class="item-name"><a class="struct" href="struct.EntityLayout.html" title="struct pg_ecs::prelude::storage::EntityLayout">EntityLayout</a></div><div class="desc docblock-short">Describes the component types which are attached to an entity.</div></li><li><div class="item-name"><a class="struct" href="struct.GroupDef.html" title="struct pg_ecs::prelude::storage::GroupDef">GroupDef</a></div><div class="desc docblock-short">Describes the components in a component group.</div></li><li><div class="item-name"><a class="struct" href="struct.MultiMut.html" title="struct pg_ecs::prelude::storage::MultiMut">MultiMut</a></div><div class="desc docblock-short">Provides mutable access to multiple different component storages from a single world.</div></li><li><div class="item-name"><a class="struct" href="struct.PackOptions.html" title="struct pg_ecs::prelude::storage::PackOptions">PackOptions</a></div><div class="desc docblock-short">Describes how to perform a component pack operation.</div></li><li><div class="item-name"><a class="struct" href="struct.PackedStorage.html" title="struct pg_ecs::prelude::storage::PackedStorage">PackedStorage</a></div><div class="desc docblock-short">Stores a slice of components of type <code>T</code> for each archetype.
Archetype slices are sorted according to the group that component <code>T</code> belongs to.
Each slice <em>may</em> be packed into a single allocation to optimise for group-based access.</div></li><li><div class="item-name"><a class="struct" href="struct.SearchIndex.html" title="struct pg_ecs::prelude::storage::SearchIndex">SearchIndex</a></div><div class="desc docblock-short">An index of archetype layouts used to accelerate query evaluation.</div></li><li><div class="item-name"><a class="struct" href="struct.U64Hasher.html" title="struct pg_ecs::prelude::storage::U64Hasher">U64Hasher</a></div><div class="desc docblock-short">A hasher optimized for hashing types that are represented as a u64.</div></li><li><div class="item-name"><a class="struct" href="struct.UnknownComponentWriter.html" title="struct pg_ecs::prelude::storage::UnknownComponentWriter">UnknownComponentWriter</a></div><div class="desc docblock-short">Provides the ability to append new components to the entities in an archetype.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.ArchetypeSource.html" title="trait pg_ecs::prelude::storage::ArchetypeSource">ArchetypeSource</a></div><div class="desc docblock-short">Defines a type which can describe the layout of an archetype.</div></li><li><div class="item-name"><a class="trait" href="trait.Component.html" title="trait pg_ecs::prelude::storage::Component">Component</a></div><div class="desc docblock-short">A marker trait for all types which can be attached to an entity.</div></li><li><div class="item-name"><a class="trait" href="trait.ComponentSource.html" title="trait pg_ecs::prelude::storage::ComponentSource">ComponentSource</a></div><div class="desc docblock-short">Describes a type which can write entity components into a world.</div></li><li><div class="item-name"><a class="trait" href="trait.ComponentStorage.html" title="trait pg_ecs::prelude::storage::ComponentStorage">ComponentStorage</a></div><div class="desc docblock-short">A storage location for component data slices. Each component storage may hold once slice for
each archetype inserted into the storage.</div></li><li><div class="item-name"><a class="trait" href="trait.ConsAppend.html" title="trait pg_ecs::prelude::storage::ConsAppend">ConsAppend</a></div><div class="desc docblock-short">Prepend a new type into a cons list</div></li><li><div class="item-name"><a class="trait" href="trait.ConsFlatten.html" title="trait pg_ecs::prelude::storage::ConsFlatten">ConsFlatten</a></div><div class="desc docblock-short">transform cons list into a flat tuple</div></li><li><div class="item-name"><a class="trait" href="trait.GroupSource.html" title="trait pg_ecs::prelude::storage::GroupSource">GroupSource</a></div><div class="desc docblock-short">A type which defines a component group.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoComponentSource.html" title="trait pg_ecs::prelude::storage::IntoComponentSource">IntoComponentSource</a></div><div class="desc docblock-short">Converts a type into a <a href="trait.ComponentSource.html">ComponentSource</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoSoa.html" title="trait pg_ecs::prelude::storage::IntoSoa">IntoSoa</a></div><div class="desc docblock-short">Desribes a type which can convert itself into an <a href="trait.Soa.html">SoA</a>
representation for entity intertion.</div></li><li><div class="item-name"><a class="trait" href="trait.UnknownComponentStorage.html" title="trait pg_ecs::prelude::storage::UnknownComponentStorage">UnknownComponentStorage</a></div><div class="desc docblock-short">A storage location for component data slices. Each component storage may hold once slice for
each archetype inserted into the storage. The type of component stored is not known statically.</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Epoch.html" title="type pg_ecs::prelude::storage::Epoch">Epoch</a></div><div class="desc docblock-short">A world epoch. Epochs are incremented each time a world is packed, and are used
by the packing heuristics as a measure of age.</div></li><li><div class="item-name"><a class="type" href="type.Version.html" title="type pg_ecs::prelude::storage::Version">Version</a></div><div class="desc docblock-short">The version of a component slice. Versions are incremented when the sliace is
accessed mutably.</div></li></ul></section></div></main></body></html>