searchState.loadedDescShard("ultraviolet", 0, "<code>ultraviolet</code>\nBivectors, i.e. oriented areas.\nCalculate the exponent of a packed <code>f32x8</code>\nCalculate the exponent of a packed <code>f32x4</code>\nCalculate the exponent of a packed <code>f64x4</code>\nCalculate the exponent of a packed <code>f64x2</code>\nCalculates the lanewise maximum of both vectors. This is a …\nCalculates the lanewise maximum of both vectors. This is a …\nCalculates the lanewise maximum of both vectors. This is a …\nCalculates the lanewise maximum of both vectors. This is a …\nCalculates the lanewise minimum of both vectors. This is a …\nCalculates the lanewise minimum of both vectors. This is a …\nCalculates the lanewise minimum of both vectors. This is a …\nCalculates the lanewise minimum of both vectors. This is a …\nRounds each lane into an integer. This is a faster …\nRounds each lane into an integer. This is a faster …\nTruncates each lane into an integer. This is a faster …\nTruncates each lane into an integer. This is a faster …\nSplats the single value given across all lanes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSplats the single value given across all lanes.\nSplats the single value given across all lanes.\nReturns the argument unchanged.\nSplats the single value given across all lanes.\nReturns the argument unchanged.\nConverts the lower two <code>i32</code> lanes to two <code>f64</code> lanes (and …\nConverts the lower two <code>i32</code> lanes to two <code>f64</code> lanes (and …\nInterpolation on types for which it makes sense.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nNatural log (ln(x))\nNatural log (ln(x))\nNatural log (ln(x))\nSquare matrices.\nCalculates the lanewise maximum of both vectors. This doesn…\nCalculates the lanewise maximum of both vectors. If either …\nCalculates the lanewise maximum of both vectors. If either …\nCalculates the lanewise maximum of both vectors. If either …\nCalculates the lanewise minimum of both vectors. If either …\nCalculates the lanewise minimum of both vectors. If either …\nCalculates the lanewise minimum of both vectors. If either …\nCalculates the lanewise minimum of both vectors. If either …\nUtility functions to create projection matrices.\nhorizontal add of all the elements of the vector\nhorizontal add of all the elements of the vector\nhorizontal add of all the elements of the vector\nhorizontal add of all the elements of the vector\nRotors, i.e. constructs that describe and perform …\nRounds each lane into an integer. This saturates out of …\nRounds each lane into an integer. This saturates out of …\nDedicated transformation types as the combination of …\nTranspose matrix of 8x8 <code>f32</code> matrix. Currently only …\nTruncates each lane into an integer. This saturates out of …\nTruncates each lane into an integer. This saturates out of …\nVectors and points, i.e. directed line segments and …\nA bivector in 2d space.\nA bivector in 2d space.\nA bivector in 2d space.\nA bivector in 3d space.\nA bivector in 3d space.\nA bivector in 3d space.\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate the bivector which represents the same plane of …\nCreate the bivector which represents the same plane of …\nCreate the bivector which represents the same plane of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nPure linear interpolation, i.e. …\nSpherical-linear interpolation.\nA 2x2 square matrix.\nA 2x2 square matrix.\nA 2x2 square matrix.\nA 3x3 square matrix.\nA 3x3 square matrix.\nA 3x3 square matrix.\nA 4x4 square matrix.\nA 4x4 square matrix.\nA 4x4 square matrix.\nThe adjugate of this matrix, i.e. the transpose of the …\nThe adjugate of this matrix, i.e. the transpose of the …\nThe adjugate of this matrix, i.e. the transpose of the …\nThe adjugate of this matrix, i.e. the transpose of the …\nThe adjugate of this matrix, i.e. the transpose of the …\nThe adjugate of this matrix, i.e. the transpose of the …\nThe adjugate of this matrix, i.e. the transpose of the …\nThe adjugate of this matrix, i.e. the transpose of the …\nThe adjugate of this matrix, i.e. the transpose of the …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes.\nInterpret <code>self</code> as a slice of bytes.\nInterpret <code>self</code> as a slice of bytes.\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a statically-sized array of its …\nInterpret <code>self</code> as a statically-sized array of its …\nInterpret <code>self</code> as a statically-sized array of its …\nInterpret <code>self</code> as a statically sized array of the …\nInterpret <code>self</code> as a statically sized array of the …\nInterpret <code>self</code> as a statically sized array of the …\nInterpret <code>self</code> as a statically sized array of its …\nInterpret <code>self</code> as a statically sized array of its …\nInterpret <code>self</code> as a statically sized array of its …\nInterpret <code>self</code> as a slice of its component (column) vector …\nInterpret <code>self</code> as a slice of its component (column) vector …\nInterpret <code>self</code> as a slice of its component (column) vector …\nInterpret <code>self</code> as a slice of the component (column) …\nInterpret <code>self</code> as a slice of the component (column) …\nInterpret <code>self</code> as a slice of the component (column) …\nInterpret <code>self</code> as a slice of the component (column) vectors\nInterpret <code>self</code> as a slice of the component (column) vectors\nInterpret <code>self</code> as a slice of the component (column) vectors\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a statically sized array of the base …\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes.\nInterpret <code>self</code> as a slice of bytes.\nInterpret <code>self</code> as a slice of bytes.\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a slice of bytes\nInterpret <code>self</code> as a statically-sized array of its …\nInterpret <code>self</code> as a statically-sized array of its …\nInterpret <code>self</code> as a statically-sized array of its …\nInterpret <code>self</code> as a statically sized array of the …\nInterpret <code>self</code> as a statically sized array of the …\nInterpret <code>self</code> as a statically sized array of the …\nInterpret <code>self</code> as a statically sized array of its …\nInterpret <code>self</code> as a statically sized array of its …\nInterpret <code>self</code> as a statically sized array of its …\nInterpret <code>self</code> as a slice of its component (column) vector …\nInterpret <code>self</code> as a slice of its component (column) vector …\nInterpret <code>self</code> as a slice of its component (column) vector …\nInterpret <code>self</code> as a slice of the component (column) …\nInterpret <code>self</code> as a slice of the component (column) …\nInterpret <code>self</code> as a slice of the component (column) …\nInterpret <code>self</code> as a slice of the component (column) vectors\nInterpret <code>self</code> as a slice of the component (column) vectors\nInterpret <code>self</code> as a slice of the component (column) vectors\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nInterpret <code>self</code> as a slice of the base numeric type.\nIf the 3x3 left upper block of <code>self</code> is a rotation, return …\nIf the 3x3 left upper block of <code>self</code> is a rotation, return …\nIf the 3x3 left upper block of <code>self</code> is a rotation, return …\nIf <code>self</code> represents an affine transformation, return its …\nIf <code>self</code> represents an affine transformation, return its …\nIf <code>self</code> represents an affine transformation, return its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a rotation matrix given a bivector which defines …\nConstruct a rotation matrix given a bivector which defines …\nConstruct a rotation matrix given a bivector which defines …\nConstruct a rotation matrix given a bivector which defines …\nConstruct a rotation matrix given a bivector which defines …\nConstruct a rotation matrix given a bivector which defines …\nAngles are applied in the order roll -&gt; pitch -&gt; yaw.\nAngles are applied in the order roll -&gt; pitch -&gt; yaw.\nAngles are applied in the order roll -&gt; pitch -&gt; yaw.\nAngles are applied in the order roll -&gt; pitch -&gt; yaw\nAngles are applied in the order roll -&gt; pitch -&gt; yaw\nAngles are applied in the order roll -&gt; pitch -&gt; yaw\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nFull 4d nonuniform scaling matrix.\nFull 4d nonuniform scaling matrix.\nFull 4d nonuniform scaling matrix.\nAssumes homogeneous 2d coordinates.\nAssumes homogeneous 2d coordinates.\nAssumes homogeneous 2d coordinates.\nCreate a new rotation matrix from a rotation around the …\nCreate a new rotation matrix from a rotation around the …\nCreate a new rotation matrix from a rotation around the …\nCreate a new rotation matrix from a rotation around the …\nCreate a new rotation matrix from a rotation around the …\nCreate a new rotation matrix from a rotation around the …\nBuilds a homogeneous 2d rotation matrix (in the xy plane) …\nBuilds a homogeneous 2d rotation matrix (in the xy plane) …\nBuilds a homogeneous 2d rotation matrix (in the xy plane) …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nCreate a new rotation matrix from a rotation “around the …\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nFull 4d diagonal matrix.\nFull 4d diagonal matrix.\nFull 4d diagonal matrix.\nAssumes homogeneous 2d coordinates.\nAssumes homogeneous 2d coordinates.\nAssumes homogeneous 2d coordinates.\nAssumes homogeneous 2d coordinates.\nAssumes homogeneous 2d coordinates.\nAssumes homogeneous 2d coordinates.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTurn this into a homogeneous 2d transformation matrix.\nTurn this into a homogeneous 2d transformation matrix.\nTurn this into a homogeneous 2d transformation matrix.\nIf self represents an <code>Isometry3</code> (i.e. self is a product of …\nIf self represents an <code>Isometry3</code> (i.e. self is a product of …\nIf self represents an <code>Isometry3</code> (i.e. self is a product of …\nIf <code>self</code> is a rotation matrix, return a <code>Rotor3</code> representing …\nIf <code>self</code> is a rotation matrix, return a <code>Rotor3</code> representing …\nIf <code>self</code> is a rotation matrix, return a <code>Rotor3</code> representing …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nIf this matrix is not currently invertable, this function …\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nConstructs a ‘look-at’ matrix from an eye position, a …\nConstructs a ‘look-at’ matrix from an eye position, a …\nConstructs a ‘look-at’ matrix from an eye position, a …\nConstructs a ‘look-at’ matrix from an eye position, a …\nConstructs a ‘look-at’ matrix from an eye position, a …\nConstructs a ‘look-at’ matrix from an eye position, a …\nTransform a Vec2 by self, interpreting it as a point.\nTransform a Vec2 by self, interpreting it as a point.\nTransform a Vec2 by self, interpreting it as a point.\nTransform a Vec3 by self, interpreting it as a point.\nTransform a Vec3 by self, interpreting it as a point.\nTransform a Vec3 by self, interpreting it as a point.\nTransform a Vec2 by self, interpreting it as a vector.\nTransform a Vec2 by self, interpreting it as a vector.\nTransform a Vec2 by self, interpreting it as a vector.\nTransform a Vec3 by self, interpreting it as a vector.\nTransform a Vec3 by self, interpreting it as a vector.\nTransform a Vec3 by self, interpreting it as a vector.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nAssumes homogeneous 3d coordinates.\nTruncate <code>self</code> to a matrix consisting of the 3x3 left upper …\nTruncate <code>self</code> to a matrix consisting of the 3x3 left upper …\nTruncate <code>self</code> to a matrix consisting of the 3x3 left upper …\nProjection matrices that are intended to be used when the …\nProjection matrices that are intended to be used when the …\nProjection matrices that are intended to be used when the …\nProjection matrices that are intended to be used when the …\nOrthographic projection matrix for use with OpenGL.\nOrthographic projection matrix for use with Vulkan.\nOrthographic projection matrix for use with WebGPU or …\nPerspective projection matrix meant to be used with OpenGL.\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with reversed and infinite …\nPerspective projection matrix with reversed and infinite …\nPerspective projection matrix with reversed z-axis meant …\nPerspective projection matrix with reversed z-axis meant …\nPerspective projection matrix meant to be used with Vulkan.\nPerspective projection matrix meant to be used with WebGPU …\nOrthographic projection matrix for use with OpenGL.\nOrthographic projection matrix for use with Vulkan.\nOrthographic projection matrix for use with WebGPU or …\nPerspective projection matrix meant to be used with OpenGL.\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with reversed and infinite …\nPerspective projection matrix with reversed and infinite …\nPerspective projection matrix with reversed z-axis meant …\nPerspective projection matrix with reversed z-axis meant …\nPerspective projection matrix meant to be used with Vulkan.\nPerspective projection matrix meant to be used with WebGPU …\nOrthographic projection matrix for use with OpenGL.\nOrthographic projection matrix for use with OpenGL.\nOrthographic projection matrix for use with WebGPU or …\nPerspective projection matrix meant to be used with OpenGL.\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with reversed and infinite …\nPerspective projection matrix with reversed and infinite …\nPerspective projection matrix with reversed z-axis meant …\nPerspective projection matrix with reversed z-axis meant …\nPerspective projection matrix meant to be used with Vulkan.\nPerspective projection matrix meant to be used with WebGPU …\nOrthographic projection matrix for use with OpenGL.\nOrthographic projection matrix for use with Vulkan.\nOrthographic projection matrix for use with WebGPU or …\nPerspective projection matrix meant to be used with OpenGL.\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with infinite z-far plane …\nPerspective projection matrix with reversed and infinite …\nPerspective projection matrix with reversed and infinite …\nPerspective projection matrix with reversed z-axis meant …\nPerspective projection matrix with reversed z-axis meant …\nPerspective projection matrix meant to be used with Vulkan.\nPerspective projection matrix meant to be used with WebGPU …\nA Rotor in 2d space.\nA Rotor in 2d space.\nA Rotor in 2d space.\nA Rotor in 3d space.\nA Rotor in 3d space.\nA Rotor in 3d space.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a rotor given only an angle. This is possible in …\nConstruct a rotor given only an angle. This is possible in …\nConstruct a rotor given only an angle. This is possible in …\nConstruct a rotor given a bivector which defines a plane …\nConstruct a rotor given a bivector which defines a plane …\nConstruct a rotor given a bivector which defines a plane …\nConstruct a rotor given a bivector which defines a plane …\nConstruct a rotor given a bivector which defines a plane …\nConstruct a rotor given a bivector which defines a plane …\nAngles are applied in the order roll -&gt; pitch -&gt; yaw\nAngles are applied in the order roll -&gt; pitch -&gt; yaw\nAngles are applied in the order roll -&gt; pitch -&gt; yaw\nConvert an array that represents a quaternion in the form …\nConvert an array that represents a quaternion in the form …\nConvert an array that represents a quaternion in the form …\nConstruct a Rotor that rotates one vector to another.\nConstruct a Rotor that rotates one vector to another.\nConstruct a Rotor that rotates one vector to another.\nConstruct a Rotor that rotates one vector to another.\nConstruct a Rotor that rotates one vector to another.\nConstruct a Rotor that rotates one vector to another.\nCreate new Rotor from a rotation in the xy plane (also …\nCreate new Rotor from a rotation in the xy plane (also …\nCreate new Rotor from a rotation in the xy plane (also …\nCreate new Rotor from a rotation in the xz plane (also …\nCreate new Rotor from a rotation in the xz plane (also …\nCreate new Rotor from a rotation in the xz plane (also …\nCreate new Rotor from a rotation in the yz plane (also …\nCreate new Rotor from a rotation in the yz plane (also …\nCreate new Rotor from a rotation in the yz plane (also …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the angle and the normalized plane of the rotation …\nReturn the angle and the normalized plane of the rotation …\nReturn the angle and the normalized plane of the rotation …\nConvert this rotor into an array that represents a …\nConvert this rotor into an array that represents a …\nConvert this rotor into an array that represents a …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nThe composition of <code>self</code> with <code>q</code>, i.e. <code>self * q</code> gives the …\nThe composition of <code>self</code> with <code>q</code>, i.e. <code>self * q</code> gives the …\nThe composition of <code>self</code> with <code>q</code>, i.e. <code>self * q</code> gives the …\nRotates this rotor by another rotor in-place. Note that if …\nRotates this rotor by another rotor in-place. Note that if …\nRotates this rotor by another rotor in-place. Note that if …\nRotates this rotor by another rotor in-place. Note that if …\nRotates this rotor by another rotor in-place. Note that if …\nRotates this rotor by another rotor in-place. Note that if …\nRotates a vector by this rotor.\nRotates a vector by this rotor.\nRotates a vector by this rotor.\nRotates a vector by this rotor.\nRotates a vector by this rotor.\nRotates a vector by this rotor.\nRotates multiple vectors by this rotor.\nRotates multiple vectors by this rotor.\nRotates multiple vectors by this rotor.\nRotates this rotor by another rotor and returns the …\nRotates this rotor by another rotor and returns the …\nRotates this rotor by another rotor and returns the …\nRotates this rotor by another rotor and returns the …\nRotates this rotor by another rotor and returns the …\nRotates this rotor by another rotor and returns the …\nMultiply the angle of the rotation represented by self by …\nMultiply the angle of the rotation represented by self by …\nMultiply the angle of the rotation represented by self by …\nReturn a rotor representing the same rotatation as <code>self</code> …\nReturn a rotor representing the same rotatation as <code>self</code> …\nReturn a rotor representing the same rotatation as <code>self</code> …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nAn Isometry, aka a “rigid body transformation”.\nAn Isometry, aka a “rigid body transformation”.\nAn Isometry, aka a “rigid body transformation”.\nAn Isometry, aka a “rigid body transformation”.\nAn Isometry, aka a “rigid body transformation”.\nAn Isometry, aka a “rigid body transformation”.\nA Similarity, i.e. an Isometry but with an added uniform …\nA Similarity, i.e. an Isometry but with an added uniform …\nA Similarity, i.e. an Isometry but with an added uniform …\nA Similarity, i.e. an Isometry but with an added uniform …\nA Similarity, i.e. an Isometry but with an added uniform …\nA Similarity, i.e. an Isometry but with an added uniform …\nAppend transformation by another isometry.\nAppend transformation by another isometry.\nAppend transformation by another isometry.\nAppend transformation by another isometry.\nAppend transformation by another isometry.\nAppend transformation by another isometry.\nAdd a rotation <em>after</em> this isometry.\nAdd a rotation <em>after</em> this isometry.\nAdd a rotation <em>after</em> this isometry.\nAdd a rotation <em>after</em> this isometry.\nAdd a rotation <em>after</em> this isometry.\nAdd a rotation <em>after</em> this isometry.\nAdd a rotation <em>after</em> this similarity.\nAdd a rotation <em>after</em> this similarity.\nAdd a rotation <em>after</em> this similarity.\nAdd a rotation <em>after</em> this similarity.\nAdd a rotation <em>after</em> this similarity.\nAdd a rotation <em>after</em> this similarity.\nAdd a scaling <em>after</em> this similarity.\nAdd a scaling <em>after</em> this similarity.\nAdd a scaling <em>after</em> this similarity.\nAdd a scaling <em>after</em> this similarity.\nAdd a scaling <em>after</em> this similarity.\nAdd a scaling <em>after</em> this similarity.\nAppend transformation by another similarity.\nAppend transformation by another similarity.\nAppend transformation by another similarity.\nAppend transformation by another similarity.\nAppend transformation by another similarity.\nAppend transformation by another similarity.\nAdd a translation <em>after</em> this isometry.\nAdd a translation <em>after</em> this isometry.\nAdd a translation <em>after</em> this isometry.\nAdd a translation <em>after</em> this isometry.\nAdd a translation <em>after</em> this isometry.\nAdd a translation <em>after</em> this isometry.\nAdd a translation <em>after</em> this similarity.\nAdd a translation <em>after</em> this similarity.\nAdd a translation <em>after</em> this similarity.\nAdd a translation <em>after</em> this similarity.\nAdd a translation <em>after</em> this similarity.\nAdd a translation <em>after</em> this similarity.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrepend transformation by another isometry.\nPrepend transformation by another isometry.\nPrepend transformation by another isometry.\nPrepend transformation by another isometry.\nPrepend transformation by another isometry.\nPrepend transformation by another isometry.\nAdd a rotation <em>before</em> this isometry.\nAdd a rotation <em>before</em> this isometry.\nAdd a rotation <em>before</em> this isometry.\nAdd a rotation <em>before</em> this isometry.\nAdd a rotation <em>before</em> this isometry.\nAdd a rotation <em>before</em> this isometry.\nAdd a rotation <em>before</em> this similarity.\nAdd a rotation <em>before</em> this similarity.\nAdd a rotation <em>before</em> this similarity.\nAdd a rotation <em>before</em> this similarity.\nAdd a rotation <em>before</em> this similarity.\nAdd a rotation <em>before</em> this similarity.\nAdd a scaling <em>before</em> this similarity.\nAdd a scaling <em>before</em> this similarity.\nAdd a scaling <em>before</em> this similarity.\nAdd a scaling <em>before</em> this similarity.\nAdd a scaling <em>before</em> this similarity.\nAdd a scaling <em>before</em> this similarity.\nPrepend transformation by another similarity.\nPrepend transformation by another similarity.\nPrepend transformation by another similarity.\nPrepend transformation by another similarity.\nPrepend transformation by another similarity.\nPrepend transformation by another similarity.\nAdd a translation <em>before</em> this isometry.\nAdd a translation <em>before</em> this isometry.\nAdd a translation <em>before</em> this isometry.\nAdd a translation <em>before</em> this isometry.\nAdd a translation <em>before</em> this isometry.\nAdd a translation <em>before</em> this isometry.\nAdd a translation <em>before</em> this similarity.\nAdd a translation <em>before</em> this similarity.\nAdd a translation <em>before</em> this similarity.\nAdd a translation <em>before</em> this similarity.\nAdd a translation <em>before</em> this similarity.\nAdd a translation <em>before</em> this similarity.\nA set of two coordinates which may be interpreted as a …\nA set of two coordinates which may be interpreted as a …\nA set of two coordinates which may be interpreted as a …\nA set of three coordinates which may be interpreted as a …\nA set of three coordinates which may be interpreted as a …\nA set of three coordinates which may be interpreted as a …\nA set of four coordinates which may be interpreted as a …\nA set of four coordinates which may be interpreted as a …\nA set of four coordinates which may be interpreted as a …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nInterpret <code>self</code> as a statically-sized array of its base …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nReturns a mutable unsafe pointer to the underlying data in …\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nReturns a constant unsafe pointer to the underlying data …\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nInterpret <code>self</code> as a slice of its base numeric type\nBlend two vectors together lanewise using <code>mask</code> as a mask.\nBlend two vectors together lanewise using <code>mask</code> as a mask.\nBlend two vectors together lanewise using <code>mask</code> as a mask.\nBlend two vectors together lanewise using <code>mask</code> as a mask.\nBlend two vectors together lanewise using <code>mask</code> as a mask.\nBlend two vectors together lanewise using <code>mask</code> as a mask.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a 2d point from a homogeneous 2d <em>point</em>, performing …\nCreate a 2d point from a homogeneous 2d <em>point</em>, performing …\nCreate a 2d point from a homogeneous 2d <em>point</em>, performing …\nCreate a 3d point from a homogeneous 3d <em>point</em>, performing …\nCreate a 3d point from a homogeneous 3d <em>point</em>, performing …\nCreate a 3d point from a homogeneous 3d <em>point</em>, performing …\nCreate a 2d vector from homogeneous 2d <em>vector</em>, which simply\nCreate a 2d vector from homogeneous 2d <em>vector</em>, which simply\nCreate a 2d vector from homogeneous 2d <em>vector</em>, which simply\nCreate a 3d vector from homogeneous 2d <em>vector</em>, which simply\nCreate a 3d vector from homogeneous 2d <em>vector</em>, which simply\nCreate a 3d vector from homogeneous 2d <em>vector</em>, which simply\nThe geometric product of this and another vector, which is …\nThe geometric product of this and another vector, which is …\nThe geometric product of this and another vector, which is …\nThe geometric product of this and another vector, which is …\nThe geometric product of this and another vector, which is …\nThe geometric product of this and another vector, which is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a homogeneous 2d <em>point</em> from this vector interpreted …\nCreate a homogeneous 2d <em>point</em> from this vector interpreted …\nCreate a homogeneous 2d <em>point</em> from this vector interpreted …\nCreate a homogeneous 3d <em>point</em> from this vector interpreted …\nCreate a homogeneous 3d <em>point</em> from this vector interpreted …\nCreate a homogeneous 3d <em>point</em> from this vector interpreted …\nCreate a homogeneous 2d <em>vector</em> from this vector, meaning …\nCreate a homogeneous 2d <em>vector</em> from this vector, meaning …\nCreate a homogeneous 2d <em>vector</em> from this vector, meaning …\nCreate a homogeneous 3d <em>vector</em> from this vector, meaning …\nCreate a homogeneous 3d <em>vector</em> from this vector, meaning …\nCreate a homogeneous 3d <em>vector</em> from this vector, meaning …\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nGet the <code>core::alloc::Layout</code> of <code>Self</code>\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nLinearly interpolate between <code>self</code> and <code>end</code> by <code>t</code> between 0.0 …\nNormalize <code>self</code> in-place by interpreting it as a …\nNormalize <code>self</code> in-place by interpreting it as a …\nNormalize <code>self</code> in-place by interpreting it as a …\nNormalize <code>self</code> in-place by interpreting it as a …\nNormalize <code>self</code> in-place by interpreting it as a …\nNormalize <code>self</code> in-place by interpreting it as a …\nNormalize <code>self</code> by interpreting it as a homogeneous point, …\nNormalize <code>self</code> by interpreting it as a homogeneous point, …\nNormalize <code>self</code> by interpreting it as a homogeneous point, …\nNormalize <code>self</code> by interpreting it as a homogeneous point, …\nNormalize <code>self</code> by interpreting it as a homogeneous point, …\nNormalize <code>self</code> by interpreting it as a homogeneous point, …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nSpherical-linear interpolation between <code>self</code> and <code>end</code> based …\nConvert <code>self</code> into a Vec2 by simply removing its <code>z</code> …\nConvert <code>self</code> into a Vec2 by simply removing its <code>z</code> …\nConvert <code>self</code> into a Vec2 by simply removing its <code>z</code> …\nConvert <code>self</code> into a Vec3 by simply removing its <code>w</code> …\nConvert <code>self</code> into a Vec3 by simply removing its <code>w</code> …\nConvert <code>self</code> into a Vec3 by simply removing its <code>w</code> …\nThe wedge (aka exterior) product of two vectors.\nThe wedge (aka exterior) product of two vectors.\nThe wedge (aka exterior) product of two vectors.\nThe wedge (aka exterior) product of two vectors.\nThe wedge (aka exterior) product of two vectors.\nThe wedge (aka exterior) product of two vectors.")