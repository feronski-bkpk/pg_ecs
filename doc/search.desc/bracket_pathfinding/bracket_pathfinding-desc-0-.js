searchState.loadedDescShard("bracket_pathfinding", 0, "Implement these for handling conversion to/from 2D …\nImplement these for handling conversion to/from 2D …\nImplement this trait to support path-finding functions.\nLine-drawing iterator\nUse Bresenham’s rasterization algorithm for line …\nAn implementation of [Bresenham’s circle algorithm]. […\nA version of the Bresenham circle that does not make …\nNew type over <code>Bresenham</code> which include the <code>end</code> points when …\nUse Chebyshev distance (like Manhattan, but adds one to …\nConvenience type: you can define an angle in Degrees and …\nUse a diagonal distance, the max of the x and y distances\nRepresentation of a Dijkstra flow map. map is a vector of …\nEnumeration of available 2D Distance algorithms\nEnumeration of available FOV algorithms\nEnumeration of available 2D Distance algorithms\nUse Manhattan distance (distance up plus distance along)\nHolds the result of an A-Star navigation query. <code>destination</code>…\nHelper struct defining a 2D point in space.\nHelper struct defining a 2D point in space.\nA 2D floating-point position.\nUse the Pythagoras algorithm for determining distance - …\nUs the Pythagoras algorithm for distance, but omitting the …\nConvenience type: you can define an angle in Radians and …\nDefines a two-dimensional rectangle.\nDefines a rectangle with floating-point coordinates.\nSince we use <code>SmallVec</code>, it’s only polite to export it so …\nA <code>Vec</code>-like container that can store a small number of …\nUse a vector approach to line solving.\nDefine a line using a fast 2D vector. It may not be as …\nRequest an A-Star search. The start and end are specified …\nReturn the next point without checking if we are past <code>end</code>.\nReturn the next point without checking if we are past <code>end</code>.\nMoves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> …\nReturns a raw mutable pointer to the vector’s buffer.\nExtracts a mutable slice of the entire vector.\nReturns a raw pointer to the vector’s buffer.\nExtracts a slice containing the entire vector.\nBuilds the Dijkstra map: iterate from each starting point, …\nBuilds the Dijkstra map: iterate from each starting point, …\nThe number of items the vector can hold without …\nReturns the center of the rectangle\nReturns the center of the rectangle\nRemove all elements from the vector.\nCreate a new point from i32, this can be constant\nRemoves consecutive duplicate elements.\nRemoves consecutive duplicate elements using the given …\nRemoves consecutive elements that map to the same key.\nRetrieve the map’s dimensions. Made optional to reduce …\nDimensions\nProvides a 2D distance between points, using the specified …\nProvides a 3D distance between points, using the specified …\nCreates a draining iterator that removes the specified …\nCopy elements from a slice and append them to the vector.\nCalculates field-of-view for a map that supports …\nCalculates field-of-view for a map that supports …\nCalls a function for each x/y point in the rectangle\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a new <code>SmallVec</code> on the stack from an <code>A</code> without …\nConstructs a new <code>SmallVec</code> on the stack from an <code>A</code> without …\nConstructs a new <code>SmallVec</code> on the stack from an <code>A</code> without …\nCreates a <code>SmallVec</code> with <code>n</code> copies of <code>elem</code>.\nCreates a <code>SmallVec</code> directly from the raw components of …\nCopy the elements from a slice into a new <code>SmallVec</code>.\nCreate a point from a tuple of two i32s\nCreate a point from an x/y/z tuple\nConstruct a new <code>SmallVec</code> from a <code>Vec&lt;A::Item&gt;</code>.\nCreates a point from an <code>UltraViolet</code> vec2\nReturn a vector of tile indices to which one can path from …\nReturn the distance you would like to use for …\nRe-allocate to set the capacity to …\nReturns the rectangle’s height\nReturns the rectangle’s height\nConvert an array index to a point. Defaults to an index …\nConvert an array index to a point.\nThe maximum number of elements this vector can hold inline\nInsert an element at position <code>index</code>, shifting all elements …\nCopy elements from a slice into the vector at position …\nInsert multiple elements at position <code>index</code>, shifting all …\nReturns true if this overlaps with other\nReturns true if this overlaps with other\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts a <code>SmallVec</code> into a <code>Box&lt;[T]&gt;</code> without reallocating …\nConvert the <code>SmallVec</code> into an <code>A</code> if possible. Otherwise …\nConvert a <code>SmallVec</code> to a <code>Vec</code>, without reallocating if the …\nReturns <code>true</code> if the vector is empty\nTrue is you cannot see through the tile, false otherwise. …\nThe number of elements stored in the vector\nPlots a line between two 2D points and returns a vector of …\nUses a Bresenham’s algorithm to plot a line between two …\nUses a 2D vector algorithm to plot a line between two …\nCreates a new circle, using the Bresenham Circle algorithm.\nCreates a Bresenham Circle without allowing diagonal gaps.\nConstruct a new Dijkstra map, ready to run. You must …\nCreates a new iterator.Yields intermediate points between …\nCreates a new iterator. Yields points <code>start..=end</code>.\nDefine a vector line between two points.\nConstruct an empty vector\nMakes a new (empty) NavigationPath\nCreates a new angle in degrees.\nCreates a new angle in radians.\nCreate a new point from an x/y coordinate.\nCreate a new point from an x/y/z coordinate.\nCreates an empty Dijkstra map node.\nConstruct a new Dijkstra map, ready to run. You must …\nConvert a Point (x/y) to an array index. Defaults to an …\nConvert a Point (x/y) to an array index. Defaults to a Z, …\nReturns true if a point is inside the rectangle\nReturns true if a point is inside the rectangle\nGets a set of all tiles in the rectangle\nRemove an item from the end of the vector and return it, …\nFrom a given start point, project forward radius units at …\nAppend an item to the vector.\nRemove and return the element at position <code>index</code>, shifting …\nReserve capacity for <code>additional</code> more elements to be …\nReserve the minimum capacity for <code>additional</code> more elements …\nResizes the vector so that its length is equal to <code>len</code>.\nResizes the <code>SmallVec</code> in-place so that <code>len</code> is equal to …\nRetains only the elements specified by the predicate.\nRetains only the elements specified by the predicate.\nSets the length of a vector.\nShrink the capacity of the vector as much as possible.\nSince we use <code>SmallVec</code>, it’s only polite to export it so …\nCreates a <code>SmallVec</code> containing the arguments.\nReturns <code>true</code> if the data has spilled into a separate …\nRemove the element at position <code>index</code>, replacing it with …\nHelper for map index conversion\nConverts the point to an i32 tuple\nConverts the point to a usize tuple\nConverts the point to an UltraViolet vec2\nConverts into an UltraViolet Vec3\nShorten the vector, keeping the first <code>len</code> elements and …\nRe-allocate to set the capacity to …\nReserve capacity for <code>additional</code> more elements to be …\nReserve the minimum capacity for <code>additional</code> more elements …\nReturns the rectangle’s width\nReturns the rectangle’s width\nConstruct an empty vector with enough capacity …\nCreate a new rectangle, specifying exact dimensions\nCreate a new rectangle, specifying exact dimensions\nCreate a new rectangle, specifying X/Y Width/Height\nCreate a new rectangle, specifying X/Y Width/Height\nThe point’s X location\nThe 3D point’s X location\nThe X position of the first point (typically the left)\nThe X position of the first point (typically the left)\nThe X position of the second point (typically the right)\nThe X position of the second point (typically the right)\nThe point’s Y location\nThe 3D point’s Y location\nThe Y position of the first point (typically the top)\nThe Y position of the first point (typically the top)\nThe Y position of the second point (typically the bottom)\nThe Y position of the second point (typically the bottom)\nThe 3D point’s Z location\nCreate a zero point\nCreates a zero rectangle\nCreates a zero rectangle")