<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Queries provide efficient iteration and filtering of entity components in a world."><title>legion::query - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="legion" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../legion/index.html">legion</a><span class="version">0.3.1</span></h2></div><h2 class="location"><a href="#">Module query</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate legion</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">legion</a>::<wbr><a class="mod" href="#">query</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/legion/query.rs.html#1-104">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Queries provide efficient iteration and filtering of entity components in a world.</p>
<p>Queries are defined by two parts; “views” and “filters”.
Views declare what data you want to access it, and how you want to access it.
Filters decide which entities are to be included in the results.</p>
<p>To construct a query, we declare our view, and then call <code>::query()</code> to convert it into
a query with an initial filter which selects entities with all of the component types
requested by the view.</p>
<p>View types include <a href="../world/struct.Entity.html">Entity</a>, <a href="struct.Read.html">Read</a>,
<a href="struct.Write.html">Write</a>, <a href="struct.TryRead.html">TryRead</a> and <a href="struct.TryWrite.html">TryWrite</a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// a view can be a single view type
</span><span class="kw">let </span><span class="kw-2">mut </span>query = &lt;<span class="kw-2">&amp;</span>Position&gt;::query();

<span class="comment">// or a tuple of views
</span><span class="kw">let </span><span class="kw-2">mut </span>query = &lt;(<span class="kw-2">&amp;</span>Position, <span class="kw-2">&amp;mut </span>Orientation)&gt;::query();</code></pre></div>
<p>You can attach additional filters to a query to further refine which entities you want to access.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="comment">// filters can be combined with boolean operators
</span><span class="kw">let </span><span class="kw-2">mut </span>query = &lt;(<span class="kw-2">&amp;</span>Position, <span class="kw-2">&amp;mut </span>Orientation)&gt;::query()
    .filter(!component::&lt;Static&gt;() | !component::&lt;Model&gt;());</code></pre></div>
<p>Once you have a query, you can use it to pull data out of a world. At its core, a query
allows you to iterate over <a href="struct.ChunkView.html">chunks</a>. Each chunk contains a set of
entities which all have extactly the same component types attached, and the chunk provides
access to slices of each component. A single index in each slice in a chunk contains the
component for the same entity.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>query = &lt;(<span class="kw-2">&amp;</span>Position, <span class="kw-2">&amp;mut </span>Orientation)&gt;::query();
<span class="kw">for </span><span class="kw-2">mut </span>chunk <span class="kw">in </span>query.iter_chunks_mut(<span class="kw-2">&amp;mut </span>world) {
    <span class="comment">// we can access information about the archetype (shape/component layout) of the entities
    </span><span class="macro">println!</span>(
        <span class="string">"the entities in the chunk have {:?} components"</span>,
        chunk.archetype().layout().component_types(),
    );

    <span class="comment">// we can iterate through a tuple of component references
    </span><span class="kw">for </span>(position, orientation) <span class="kw">in </span>chunk {
        <span class="comment">// position is a `&amp;Position`
        // orientation is a `&amp;mut Orientation`
        // they are both attached to the same entity
    </span>}
}</code></pre></div>
<p>There are convenience functions on query which will flatten this loop for us, giving
direct access to the entities.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>query = &lt;(<span class="kw-2">&amp;</span>Position, <span class="kw-2">&amp;mut </span>Orientation)&gt;::query();
<span class="kw">for </span>(position, orientation) <span class="kw">in </span>query.iter_mut(<span class="kw-2">&amp;mut </span>world) {
    <span class="comment">// position is a `&amp;Position`
    // orientation is a `&amp;mut Orientation`
    // they are both attached to the same entity
</span>}</code></pre></div>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.IntoIndexableIter"><code>pub use crate::internals::query::view::IntoIndexableIter;</code></div></li><li><div class="item-name" id="reexport.ReadOnly"><code>pub use crate::internals::query::view::ReadOnly;</code></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.And.html" title="struct legion::query::And">And</a></div><div class="desc docblock-short">A filter which requires all filters within <code>T</code> match.</div></li><li><div class="item-name"><a class="struct" href="struct.Any.html" title="struct legion::query::Any">Any</a></div><div class="desc docblock-short">A filter which always matches <code>true</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.ChunkIter.html" title="struct legion::query::ChunkIter">ChunkIter</a></div><div class="desc docblock-short">An iterator which yields entity chunks from a query.</div></li><li><div class="item-name"><a class="struct" href="struct.ChunkView.html" title="struct legion::query::ChunkView">ChunkView</a></div><div class="desc docblock-short">Provides access to slices of components for entities which have the same component layout.</div></li><li><div class="item-name"><a class="struct" href="struct.ComponentChangedFilter.html" title="struct legion::query::ComponentChangedFilter">ComponentChangedFilter</a></div><div class="desc docblock-short">A filter which performs course-grained change detection.</div></li><li><div class="item-name"><a class="struct" href="struct.ComponentFilter.html" title="struct legion::query::ComponentFilter">ComponentFilter</a></div><div class="desc docblock-short">A filter which matches <code>true</code> when the given component exists in the archetype.</div></li><li><div class="item-name"><a class="struct" href="struct.Iter.html" title="struct legion::query::Iter">Iter</a></div><div class="desc docblock-short">An entity chunk iterator which internally locks its filter during iteration.</div></li><li><div class="item-name"><a class="struct" href="struct.Not.html" title="struct legion::query::Not">Not</a></div><div class="desc docblock-short">A filter which negates <code>F</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Or.html" title="struct legion::query::Or">Or</a></div><div class="desc docblock-short">A filter which requires any filter within <code>T</code> match.</div></li><li><div class="item-name"><a class="struct" href="struct.ParChunkIter.html" title="struct legion::query::ParChunkIter">ParChunkIter</a></div><div class="desc docblock-short">A parallel entity chunk iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.Passthrough.html" title="struct legion::query::Passthrough">Passthrough</a></div><div class="desc docblock-short">A filter which always defers.</div></li><li><div class="item-name"><a class="struct" href="struct.Query.html" title="struct legion::query::Query">Query</a></div><div class="desc docblock-short">Provides efficient means to iterate and filter entities in a world.</div></li><li><div class="item-name"><a class="struct" href="struct.Read.html" title="struct legion::query::Read">Read</a></div><div class="desc docblock-short">Reads a single entity data component type from a chunk.</div></li><li><div class="item-name"><a class="struct" href="struct.TryComponentFilter.html" title="struct legion::query::TryComponentFilter">TryComponentFilter</a></div><div class="desc docblock-short">A filter which matches <code>true</code> if the entity has the given component,
else it will defer.</div></li><li><div class="item-name"><a class="struct" href="struct.TryRead.html" title="struct legion::query::TryRead">TryRead</a></div><div class="desc docblock-short">Reads a single entity data component type from a chunk.</div></li><li><div class="item-name"><a class="struct" href="struct.TryWrite.html" title="struct legion::query::TryWrite">TryWrite</a></div><div class="desc docblock-short">Writes a single entity data component type from a chunk.</div></li><li><div class="item-name"><a class="struct" href="struct.Write.html" title="struct legion::query::Write">Write</a></div><div class="desc docblock-short">Writes a single mutable entity data component type from a chunk.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.FilterResult.html" title="enum legion::query::FilterResult">FilterResult</a></div><div class="desc docblock-short">Indicates if an an archetype should be accepted or rejected.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.DefaultFilter.html" title="trait legion::query::DefaultFilter">DefaultFilter</a></div><div class="desc docblock-short">Declares the default filter type used by a view when it is converted into a query.</div></li><li><div class="item-name"><a class="trait" href="trait.DynamicFilter.html" title="trait legion::query::DynamicFilter">DynamicFilter</a></div><div class="desc docblock-short">A filter which selects based upon the data available in the archetype.</div></li><li><div class="item-name"><a class="trait" href="trait.EntityFilter.html" title="trait legion::query::EntityFilter">EntityFilter</a></div><div class="desc docblock-short">A combination of a <a href="trait.LayoutFilter.html">LayoutFilter</a> and a
<a href="trait.DynamicFilter.html">DynamicFilter</a>.</div></li><li><div class="item-name"><a class="trait" href="trait.Fetch.html" title="trait legion::query::Fetch">Fetch</a></div><div class="desc docblock-short">A type which holds onto a slice of entitiy data retrieved from a single archetype.</div></li><li><div class="item-name"><a class="trait" href="trait.GroupMatcher.html" title="trait legion::query::GroupMatcher">GroupMatcher</a></div><div class="desc docblock-short">Allows a filter to determine if component optimization groups can
be used to accelerate queries that use this filter.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoQuery.html" title="trait legion::query::IntoQuery">IntoQuery</a></div><div class="desc docblock-short">A type (typically a view) which can construct a query.</div></li><li><div class="item-name"><a class="trait" href="trait.LayoutFilter.html" title="trait legion::query::LayoutFilter">LayoutFilter</a></div><div class="desc docblock-short">A filter which selects based upon which component types are attached to an entity.</div></li><li><div class="item-name"><a class="trait" href="trait.View.html" title="trait legion::query::View">View</a></div><div class="desc docblock-short">A type which can pull entitiy data out of a world.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.any.html" title="fn legion::query::any">any</a></div><div class="desc docblock-short">Constructs a filter which passes all entities.</div></li><li><div class="item-name"><a class="fn" href="fn.component.html" title="fn legion::query::component">component</a></div><div class="desc docblock-short">Constructs a filter which requires that the entities have the given component.</div></li><li><div class="item-name"><a class="fn" href="fn.maybe_changed.html" title="fn legion::query::maybe_changed">maybe_changed</a></div><div class="desc docblock-short">Constructs a filter which requires that the component cannot be certain to have not changed.</div></li><li><div class="item-name"><a class="fn" href="fn.passthrough.html" title="fn legion::query::passthrough">passthrough</a></div><div class="desc docblock-short">Constructs a filter which performs a no-op and defers to any filters it is combined with.</div></li></ul></section></div></main></body></html>